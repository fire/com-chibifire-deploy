# Copyright 2016 K. S. Ernest (iFire) Lee
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
#
# Snappydata cluster on Kubernetes
# This is based on the cockroachdb example
# ## Two ways to connect to the database:
# * minikube service  snappydata-public --url
# * Connect to the cluster dashboardand see what snappydata-public's
# LoadBalancer ip in service pane.
# ## To view pulse cluster admin app:
# kubectl port-forward snappydata-locator-0 7070
apiVersion: v1
kind: Service
metadata:
  # This service is meant to be used by clients of the database. It exposes a ClusterIP that will
  # automatically load balance connections to the different database pods.
  name: snappydata-public
  namespace: snappydata
  labels:
    app: snappydata
spec:
  ports:
  - port: 1527
    targetPort: 1527
    name: jdbc
  - port: 1531
    targetPort: 1531
    name: thrift
  type: ClusterIP # In a cloud switch to LoadBalancer
  selector:
    app: snappydata-server
---
apiVersion: v1
kind: Service
metadata:
  # This service is meant to be used by clients of the database. It exposes the pulse management 
  # application.
  name: snappydata-pulse-public
  namespace: snappydata
  labels:
    app: snappydata
spec:
  ports:
  - port: 7075
    targetPort: 7075
    name: pulse
  selector:
    app: snappydata-locator
---
apiVersion: v1
kind: Service
metadata:
  # This service is meant to be used by clients of the database. It exposes the locator so that the
  # servers can find other servers.
  name: snappydata-locator-public
  namespace: snappydata
  labels:
    app: snappydata
spec:
  ports:
  - port: 1527
    targetPort: 1527
    name: jdbc
  - port: 10334
    targetPort: 10334
    name: locator
  selector:
    app: snappydata-locator
---
apiVersion: v1
kind: Service
metadata:
  # This service is meant to be used by clients of the database. It exposes a ClusterIP that will
  # automatically load balance connections to the different database pods.
  name: snappydata-server-public
  namespace: snappydata
  labels:
    app: snappydata
spec:
  ports:
  - port: 1527
    targetPort: 1527
    name: jdbc
  - port: 10334
    targetPort: 10334
    name: locator
  selector:
    app: snappydata-server
---
apiVersion: v1
kind: Service
metadata:
  # This service is meant to be used by clients of the database. It exposes a ClusterIP that will
  # automatically load balance connections to the different database pods.
  name: snappydata-leader-public
  namespace: snappydata
  labels:
    app: snappydata
spec:
  ports:
  - port: 4040
    targetPort: 4040
    name: spark-ui
  selector:
    app: snappydata-leader
---
apiVersion: v1
kind: Service
metadata:
  # This service only exists to create DNS entries for each pod in the stateful
  # set such that they can resolve each other's IP addresses. It does not
  # create a load-balanced ClusterIP and should not be used directly by clients
  # in most circumstances.
  name: snappydata-locator
  namespace: snappydata
  labels:
    app: snappydata-locator
  annotations:
    # This is needed to make the peer-finder work properly and to help avoid
    # edge cases where instance 0 comes up after losing its data and needs to
    # decide whether it should create a new cluster or try to join an existing
    # one. If it creates a new cluster when it should have joined an existing
    # one, we'd end up with two separate clusters listening at the same service
    # endpoint, which would be very bad.
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    # Enable automatic monitoring of all instances when Prometheus is running in the cluster.
    prometheus.io/scrape: "true"
    prometheus.io/path: "_status/vars"
    prometheus.io/port: "8080"
spec:
  ports:
  - port: 10334
    targetPort: 10334
    name: locator
  - port: 3768
    targetPort: 3768
    name: zeppelin
  - port: 1531
    targetPort: 1531
    name: thrift
  - port: 1527
    targetPort: 1527
    name: jdbc
  clusterIP: None
  selector:
    app: snappydata-locator
---
apiVersion: v1
kind: Service
metadata:
  # This service only exists to create DNS entries for each pod in the stateful
  # set such that they can resolve each other's IP addresses. It does not
  # create a load-balanced ClusterIP and should not be used directly by clients
  # in most circumstances.
  name: snappydata-server
  namespace: snappydata
  labels:
    app: snappydata-server
  annotations:
    # This is needed to make the peer-finder work properly and to help avoid
    # edge cases where instance 0 comes up after losing its data and needs to
    # decide whether it should create a new cluster or try to join an existing
    # one. If it creates a new cluster when it should have joined an existing
    # one, we'd end up with two separate clusters listening at the same service
    # endpoint, which would be very bad.
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
    # Enable automatic monitoring of all instances when Prometheus is running in the cluster.
    prometheus.io/scrape: "true"
    prometheus.io/path: "_status/vars"
    prometheus.io/port: "8080"
spec:
  ports:
  - port: 10334
    targetPort: 10334
    name: locator
  - port: 3768
    targetPort: 3768
    name: zeppelin
  - port: 1531
    targetPort: 1531
    name: thrift
  - port: 1527
    targetPort: 1527
    name: jdbc
  clusterIP: None
  selector:
    app: snappydata-server
